# -*- coding: utf-8 -*-
"""
/***************************************************************************
 EISWizardDialog
                                 A QGIS plugin
 QGIS GUI for EIS Toolkit
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-11-15
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Gispo
        email                : niko@gispo.fi
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'eis_wizard_dialog_base.ui'))


class EISWizardDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, plugin, parent=None):
        """Constructor."""
        super(EISWizardDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.plugin = plugin
        self.setupUi(self)
        self.connect_buttons()

    def set_interface(self, interface):
        self.interface = interface

    # SETTINGS FUNCTIONS
    def connect_setting_button(self, button, callback, arguments = None):
        if arguments is None:
            button.clicked.connect(callback)
        else:
            button.clicked.connect(lambda: callback(arguments))

    # def connect_pythonPathButton(self):
    #     self.setPythonPathButton.clicked.connect(self.plugin.set_python_path())

    # def connect_toolkitInterfaceButton(self):
    #     self.setToolkitInterfacePathButton.clicked.connect(self.plugin.set_toolkit_interface_path())


    # # ASD
    # def connect_resampleRasterDialog(self):
    #     self.resampleDialog = EISWizardDialog(parent=self)
    #     self.resampleDialog.show() # Show the dialog
    #     result = self.dlg.exec_() # Run the dialog event loop
        
    # TOOLKIT CALL FUNCTIONS
    def connect_resampleRasterButton(self):
        func_name = "call_resample"
        func_parameters = ["/home/niko/code/eis_toolkit/tests/data/remote/small_raster.tif",
        "/home/niko/GIS_data/output_raster2.tif",
        "3",
        "bilinear"]
        arguments = [func_name] + func_parameters
        self.resampleRasterButton.clicked.connect(lambda: self.interface.run_toolkit_function(arguments))

    # def connect_reprojectRasterButton(self):
    #     func_name = "reproject_raster"
    #     func_parameters = []
    #     arguments = list(func_name) + func_parameters
    #     self.reprojectRasterButton.clicked.connect(lambda: self.interface.run_toolkit_function(arguments))
    
    # def connect_clipRasterButton(self):
    #     func_name = "clip"
    #     func_parameters = []
    #     arguments = list(func_name) + func_parameters
    #     self.clipRasterButton.clicked.connect(lambda: self.interface.run_toolkit_function(arguments))

    # # FAKE/TEST FUNCTIONS
    # def connect_runScriptButton(self):
    #     func_name = "run_script" # Fake function
    #     func_parameters = []
    #     arguments = list(func_name) + func_parameters
    #     self.runScriptButton.clicked.connect(lambda: self.interface.run_toolkit_function(arguments))

    # def connect_visualizeButton(self):
    #     pass


    # CONNECT BUTTONS TO FUNCTIONS
    def connect_buttons(self):
        """Calls all individual button connector functions."""
        # Could we go through all UI elements and if elem name has "Button", 
        # we would call a function with a certain name? Something like this:

        # for attr_name, value in self.__dict__.items():
        #     print(attr_name, value)
        #     if isinstance(value, ActivationButton):
        #         func_name = "connect_" + str(attr_name)
        #         self.attr_name.clicked.connect(lambda: func_name(self))

        self.connect_resampleRasterButton()
        #self.connect_resampleRasterDialog()

        self.connect_setting_button(self.setPythonPathButton, self.plugin.set_python_path)
        self.connect_setting_button(self.setToolkitInterfacePathButton, self.plugin.set_toolkit_interface_path)

        # self.connect_pythonPathButton(self)
        # self.connect_toolkitInterfaceButton
